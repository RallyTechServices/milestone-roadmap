<!DOCTYPE html>
<html>
<head>
    <title>TS Milestone Roadmap</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Nov 12 2015 20:04:26 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Nov 12 2015 20:04:26 GMT-0800 (PST)";
        var CHECKSUM = 46320942664;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('ProjectPickerDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.projectpickerdialog',


    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemschosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemschosen', this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },
    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }
        Ext.create('Rally.data.wsapi.ProjectTreeStoreBuilder').build({
            models: ['project'],
            autoLoad: true,
            enableHierarchy: true,
            filters: [{
                property: 'Parent',
                value: ""
            }]
        }).then({
            scope: this,
            success: function(store) {

                var mode = this.multiple ? 'MULTI' : 'SINGLE';

                var checkbox_model = Ext.create('Rally.ui.selection.CheckboxModel', {
                    mode: mode,
                    enableKeyNav: false,
                    allowDeselect: true
                });

                this.grid = this.add({
                    xtype: 'rallytreegrid',
                    treeColumnDataIndex: 'Name',
                    treeColumnHeader: 'Name',
                    viewConfig: {
                        cls: 'grid-view-bulk-edit'
                    },
                    enableRanking: false,
                    enableEditing: false,
                    enableBulkEdit: false,
                    shouldShowRowActionsColumn: false,

                    selModel: checkbox_model,
                    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                        store = store.treeStore || store;
                        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('Name')).apply(record.data);
                    },
                    columnCfgs: [],
                    store: store
                });

                this.mon(this.grid, {
                    beforeselect: this._onGridSelect,
                    beforedeselect: this._onGridDeselect,
                    load: this._onGridLoad,
                    scope: this
                });
                this.add(this.grid);
                this._onGridReady();
            }
        });
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);

        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }
        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },
    _onGridLoad: function() {
        //console.log('_onGridLoad');
        var store = this.grid.store;
        var records = [];
        _.each(this.selectionCache, function(record) {
            var foundNode = store.getRootNode().findChild('_ref', record.get('_ref'),true);

            if (foundNode) {
                records.push(foundNode);
            }
        });
        if (records.length) {
            this.grid.getSelectionModel().select(records);
        }
    },
    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        //Filter functions call store load so we don't need to refresh the selections becuaes the
        //onGridLoad function will
        if (terms) {
            store.filter([
                Ext.create('Rally.data.wsapi.Filter',{
                    property: 'Name',
                    operator: 'contains',
                    value: terms
                })
            ]);
        } else {
            store.clearFilter();
        }

    },
    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

Ext.override(Rally.data.wsapi.ParentChildMapper, {
    constructor: function() {
        this.parentChildTypeMap = {
            project: [{
                typePath: 'project', collectionName: 'Children', parentField: 'Parent'
            }],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    }
});


Ext.define('Rally.data.wsapi.ProjectTreeStore', {

    // Client Metrics Note: WsapiTreeStore is too low level to record its load begins/ends. The problem is
    // client metrics can only reliably keep track of one load per component at a time. WsapiTreeStore makes
    // no guarantee that only one load will happen at a time. It's better to measure the component that is using
    // the store. All is not lost, the actual data requests that WsapiTreeStore makes *are* measured by client metrics.

    requires: [
        'Deft.promise.Deferred',
        'Rally.data.ModelFactory',
        'Rally.ui.grid.data.NodeInterface',
        'Rally.data.ModelTypes',
        'Rally.data.wsapi.ParentChildMapper'
    ],
    extend: 'Rally.data.wsapi.TreeStore',
    alias: 'store.rallyprojectwsapitreestore',

    /**
     * The type definition typePaths to render as root items (required)
     * @cfg {String[]} parentTypes
     */
    parentTypes: ['project'],

    /**
     * @property
     * @private
     */
    childLevelSorters: [{
        property: 'Name',
        direction: 'ASC'
    }],

    getParentFieldNamesByChildType: function(childType, parentType) {
        var model = this.model; //.getArtifactComponentModel(childType);
        return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
            var typePath = field.typePath,
                fieldName = field.fieldName,
            // hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);
                hasFieldModel = model.hasField(fieldName);

            if (hasFieldModel) {
                acc.push(fieldName.replace(/\s+/g, ''));
            }
        }, [], this);
    },

    filter: function(filters) {
        this.fireEvent('beforefilter', this);
        //We need to clear the filters to remove the Parent filter
        this.filters.clear();
        this.filters.addAll(filters);
        this._resetCurrentPage();
        this.load();
    },

    clearFilter: function(suppressEvent) {
        this._resetCurrentPage();
        this.filters.clear();
        //We need to add the parent filter back in
        this.filters.addAll(Ext.create('Rally.data.wsapi.Filter',{
            property: 'Parent',
            value: ''
        }));

        if (!suppressEvent) {
            this.load();
        }
    }
});

Ext.define('Rally.data.wsapi.ProjectTreeStoreBuilder', {
    extend: 'Rally.data.wsapi.TreeStoreBuilder',

    build: function(config) {
        //A context needs to be passed in here, and it NEEDS to be a DataContext (context.getDataContext())
        //otherwise you will get a bunch of garbage on your WSAPI request

        config = _.clone(config || {});
        config.storeType = 'Rally.data.wsapi.ProjectTreeStore';

        return this.loadModels(config).then({
            success: function(models) {
                models = _.values(models);
                return this._buildStoreWithModels(models, config);
            },
            scope: this
        });
    }
});
Ext.define('TechnicalServices.ProjectSettingGroups',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.projectgroupsettings',
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){

        this.callParent();
        this.addEvents('ready');

        this.setLoading('loading...');
        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name'],
            context: {
                project: null
            },
            limit: 'Infinity'
        });
        store.load({
            scope: this,
            callback: this._buildProjectGrid
        });

    },

    _buildProjectGrid: function(records, operation, success){
        this.setLoading(false);
        var container = Ext.create('Ext.container.Container',{
            layout: { type:'hbox' },
            renderTo: this.inputEl,
            minHeight: 50,
            minWidth: 50
        });
        
        var decodedValue = {};
        if (this.initialConfig && this.initialConfig.value && !_.isEmpty(this.initialConfig.value)){
            if (!Ext.isObject(this.initialConfig.value)){
                decodedValue = Ext.JSON.decode(this.initialConfig.value);
            } else {
                decodedValue = this.initialConfig.value;
            }
        }

        var data = [],
            empty_text = "No exceptions";

        if (success) {
            _.each(records, function(project){
                var groupName = decodedValue[project.get('_ref')];
                if ( groupName || groupName == "" ) {
                    data.push({projectRef: project.get('_ref'), projectName: project.get('Name'), groupName: groupName});
                }
            });
        } else {
            empty_text = "Error(s) fetching Project data: <br/>" + operation.error.errors.join('<br/>');
        }

        var custom_store = Ext.create('Ext.data.Store', {
            fields: ['projectRef', 'projectName', 'groupName'],
            data: data
        });
        
        var gridWidth = Math.min(this.inputEl.getWidth(true)-100, 400);
        this.inputEl.set
        this._grid = container.add(  {
            xtype:'rallygrid',
            autoWidth: true,
            columnCfgs: this._getColumnCfgs(),
            showPagingToolbar: false,
            store: custom_store,
            height: 150,
            width: gridWidth,
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        var width = Math.min(this.inputEl.getWidth(true)-20, 400);
        
        //Ext.create('Rally.ui.Button',{
        container.add({
            xtype: 'rallybutton',
            text: 'Select Projects',
            margin: '0 0 0 10',
            listeners: {
                scope: this,
                click: function(){

                    Ext.create('ProjectPickerDialog',{
                        autoShow: true,
                        maxHeight: 300,
                        maxWidth: 400,
                        width: Math.min(width, 400),
                        title: 'Choose Project(s)',
                        selectedRefs: _.pluck(data, 'projectRef'),
                        listeners: {
                            scope: this,
                            itemschosen: function(items){
                                var new_data = [],
                                    store = this._grid.getStore();

                                _.each(items, function(item){
                                    if (!store.findRecord('projectRef',item.get('_ref'))){
                                        new_data.push({
                                            projectRef: item.get('_ref'),
                                            projectName: item.get('Name'),
                                            groupName: null
                                        });
                                    }
                                });
                                this._grid.getStore().add(new_data);
                            }
                        }
                    });
                }
            }
        });

       this.fireEvent('ready', true);
    },
    _removeProject: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            scope: this,
            rowActionsFn: function(record){
                return  [
                    {text: 'Remove', record: record, handler: me._removeProject, grid: me._grid }
                ];
            },
            //Need to override this since we are using a custom store
            _renderGearIcon: function(value, metaData, record) {
                return '<div class="row-action-icon icon-gear"/>';
            }
        },{
                text: 'Project',
                dataIndex: 'projectRef',
                flex: 1,
                editor: false,
                renderer: function(v, m, r){
                    return r.get('projectName');
                },
                getSortParam: function(v,m,r){
                    return 'projectName';
                }
        },{
            text: 'Group Name',
            dataIndex: 'groupName',
            editor: {
                xtype: 'rallytextfield'
            }
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {};
        var store = this._grid.getStore();

        store.each(function(record) {
            if (record.get('projectRef')) {
                mappings[record.get('projectRef')] = record.get('groupName') || "";
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});
Ext.define('TSUtilities',{
    singleton: true,
    logger: new Rally.technicalservices.Logger(),

    loadWSAPIItems: function(config){
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        this.logger.log(config.model, "Loading with filters: ", Ext.clone(config.filters));
        
        var default_config = {
            fetch: ['ObjectID']
        };
        
        Ext.create('Rally.data.wsapi.Store', Ext.merge(default_config,config)).load({
            callback : function(records, operation, successful) {
                if (successful){
                    deferred.resolve(records);
                } else {
                    me.logger.log("Failed: ", operation);
                    deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                }
            }
        });
        return deferred.promise;
    }
});
/**
 *
 */
Ext.define('Rally.techservices.ColorSettingsField', {
    extend: 'Ext.form.field.Base',
    alias: 'widget.colorsettingsfield',
    plugins: ['rallyfieldvalidationui'],

    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',

    cls: 'column-settings',

    config: {
        /**
         * @cfg {Object}
         *
         * The column settings value for this field
         */
        value: undefined
    },

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },

    onRender: function() {
        this.callParent(arguments);

        this._store = Ext.create('Ext.data.Store', {
            fields: ['state', 'colorStateMapping'],
            data: []
        });

        var gridWidth = Math.min(this.getWidth(true)-100, 400);

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            maxWidth: gridWidth,
            height: 150,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
            showPagingToolbar: false,
            showRowActionsColumn: false,
            enableRanking: false,
            store: this._store,
            editingConfig: {
                publishMessages: false
            }
        });
        
        this._getStateField();
    },
    
    _getStateField: function() {
        var me = this;
        config = {
            model: 'TypeDefinition', 
            fetch: ["TypePath"],
            filters: [ { property:"Ordinal", operator:"=", value:1} ]
        };
        
        TSUtilities.loadWSAPIItems(config).then({
            scope: this,
            success: function(types) {
                var type = types[0];
                var type_path = type.get('TypePath');
                
                Rally.data.ModelFactory.getModel({
                    type: type_path,
                    success: function(model) {
                        var field = model.getField('State');
                        me.refreshWithNewField(field);
                    }
                });

            },
            failure: function(msg) {
                alert("Problem loading PI type: " + msg);
            }
        });
    },

    _getColumnCfgs: function() {
        var columns = [
            {
                text: 'State',
                dataIndex: 'state',
                emptyCellText: 'None',
                flex: 1
            },
            {
                text: 'Color',
                dataIndex: 'colorStateMapping',
                editor: {
                    xtype: 'rallytextfield',
                    flex: 1
//                    validator: function (value) {
//                        return (value === '' || (value > 0 && value <= 9999)) || 'WIP must be > 0 and < 9999.';
//                    },
//                    rawToValue: function (value) {
//                        return value === '' ? value : parseInt(value, 10);
//                    }
                }
            }
        ];

        return columns;
    },

    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode( this._buildSettingValue() );
        return data;
    },

    _buildSettingValue: function() {
        var columns = {};
        this._store.each(function(record) {
            columns[record.get('state')] = record.get('colorStateMapping');
        }, this);
        return columns;
    },

    getErrors: function() {
        var errors = [];
        if (this._storeLoaded && !Ext.Object.getSize(this._buildSettingValue())) {
            errors.push('At least one column must be shown.');
        }
        return errors;
    },

    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    },

    _getColumnValue: function(stateName) {
        var value = this._value;

        if ( Ext.isEmpty(value) ) {
            return null;
        }
        
        if ( Ext.isString(value) ) {
            value = Ext.JSON.decode(value);
        }
        
        if ( Ext.isString(value)[stateName] ) {
            return Ext.JSON.decode(value)[stateName];
        }

        return value[stateName];
    },

    refreshWithNewField: function(field) {
        delete this._storeLoaded;
        field.getAllowedValueStore().load({
            callback: function(records, operation, success) {
                var data = Ext.Array.map(records, this._recordToGridRow, this);
                
                this._store.loadRawData(data);
                this.fireEvent('ready');
                this._storeLoaded = true;
            },
            scope: this
        });
    },

    _recordToGridRow: function(allowedValue) {
        var stateName = allowedValue.get('StringValue');
        var pref = this._store.getCount() === 0 ? this._getColumnValue(stateName) : null;

        var column = { 
            state: stateName,
            colorStateMapping: ''
        };
        
        if (pref) {
            column.colorStateMapping = pref;
        }

        return column;

    }
});

/**
 * A grid that shows a roadmap.  Each row is a Rally project, each 
 * column is a month.  
 * 
 * The items that appear inside the cells has a milestone that falls into
 * the month and belongs to the project of the row.
 * 
 */
 
 Ext.define('Rally.technicalservices.RoadmapTable', {
    extend: 'Ext.Container',

    alias: 'widget.tsroadmaptable',

    /**
     * @property {String} cls The base class applied to this object's element
     */
    cls: "tsroadmap",

    config: {
        /**
         * @cfg {date} startDate 
         *
         * Monthly columns start with this date (defaults to today)
         */
        startDate: new Date(),
        /**
         * 
         * @cfg {Number} monthCount
         * Number of columns to show
         * 
         */
        monthCount: 3,
        /**
         * 
         * @cfg {Rally.data.Model} (reqd)
         * The model of items to display 
         */
        cardModel: null,
        /**
         * 
         * @cfg {object} 
         *     { state1: 'Platinum', state2: 'blue', default: 'Platinum' } 
         */
        stateColors: { 'defaultValue': 'Platinum' },
        /**
         * 
         * @cfg {object}
         *    { project_ref1: 'A', project_ref2: 'B', project_ref3: 'C', project_ref4: '' } 
         */
        projectGroups: {}
    },
    
    /**
     * @constructor
     * @param {Object} config
     */
    constructor: function (config) {
        this.mergeConfig(config);
        
        this.callParent([this.config]);
    },

    initComponent: function () {
        if ( Ext.isEmpty(this.cardModel) ) {
            console.error("Rally.technicalservices.RoadmapTable requires a model name for the cards");
            throw "Rally.technicalservices.RoadmapTable requires a model name for the cards";
        }
        this.callParent(arguments);
        
        this.addEvents(
            /**
             * @event
             * Fires when the grid has been rendered
             * @param {Rally.technicalservices.RoadmapTable} this
             * @param {Rally.ui.grid.Grid} grid
             */
            'gridReady'
        );
        var columns = this._getColumns();
        this._defineCustomModel(columns);
        
        var table_store = Ext.create('Rally.data.custom.Store',{ model: 'TSTableRow' });
        
        this.grid = this.add({ 
            xtype:'rallygrid', 
            store: table_store,
            columnCfgs: columns,
            showPagingToolbar : false,
            showRowActionsColumn : false,
            sortableColumns: false,
            disableSelection: true,
            viewConfig: {
                stripeRows: true
            }
        });
        
        this._loadCards();
    },
    
    _loadCards: function() {
        this.card_store = Ext.create('Rally.data.wsapi.Store',{
            model: 'Milestone',
            filters: [
                {property:'TargetDate', operator: '>=', value: Rally.util.DateTime.add(this.startDate, 'month', -1)},
                {property:'TargetDate', operator: '<=', value: Rally.util.DateTime.add(this.startDate, 'month', this.monthCount+1)}
            ],
            fetch: ['FormattedID', 'Name', 'Artifacts', 'ObjectID','TargetDate']
        });
                
        this.card_store.load({
            scope: this,
            callback : function(records, operation, successful) {
                if (successful){
                    this._updateRows(records, this.grid.getStore());
                } else {
                    console.error('Problem loading: ' + operation.error.errors.join('. '));
                    Ext.Msg.alert('Problem loading milestones', operation.error.errors.join('. '));
                }
            }
        });
    },

    _defineCustomModel: function(columns) {
        var me = this;
        
        var fields = Ext.Array.map(columns, function(column){
            var name = column.dataIndex;
            var type = 'object';
            if ( name == 'Project' ) { type = 'string'; }
            
            return { name: name, type: type };
        });
        
        Ext.define('TSTableRow', {
            extend: 'Ext.data.Model',
            fields: fields,
            
            addArtifact: function(artifact,milestone) {
                var month = Ext.util.Format.date(milestone, 'F');
                if ( Ext.isEmpty(this.get(month)) ) {
                    this.set(month, [artifact.getData()]);
                } else {
                    var artifacts = this.get(month);
                    artifacts.push(artifact.getData());
                    this.set(month, artifacts);
                }
            }
        });
    },
    
    cardTemplate: new Ext.XTemplate(
        "<tpl for='.'>",
            "<div class='ts_card' id='{ObjectID}' style='background-color:{__StateColor};'>{Name} ({Children.Count})</div>",
        "</tpl>"
    ),
    
    getCellRenderer: function() {
        var me = this;
        return function(value, meta, record) {
            var card_items = me._setArtifactColor(value);
            return me.cardTemplate.apply(card_items);
        }
    },
    
    _getColumns: function() {
        var columns = [{
            dataIndex: 'Project',
            text: '',
            flex: 1
        }];
        
        var month_stamp = Rally.util.DateTime.add(new Date(), 'month', -1);
        
        var card_renderer = this.getCellRenderer();
        
        for ( var i=0; i<9; i++ ) {
            var month = Ext.util.Format.date(month_stamp, 'F');
            columns.push({
                dataIndex: month,
                text: month,
                flex: 1,
                renderer: card_renderer,
                align: 'center'
            });
            
            month_stamp = Rally.util.DateTime.add(month_stamp, 'month', 1);
        }
        
        return columns;
    },
    
    _updateRows: function(milestones, table_store) {
        var me = this;
        var promises = [];
        
        Ext.Array.each(milestones, function(milestone){
            var oid = milestone.get('ObjectID');
            var target_date = milestone.get('TargetDate');
            
            promises.push( function() { return me._loadArtifactsForMilestone(oid,target_date); } );
        });
        
        Deft.Chain.sequence(promises).then({
            scope: this,
            success: function(results) {
                var me = this;
                
                var artifacts_by_milestone = {};
                Ext.Array.each(results, function(artifacts_by_a_milestone){
                    artifacts_by_milestone = Ext.apply(artifacts_by_milestone, artifacts_by_a_milestone);
                });
                
                this.artifacts_by_oid = this._getArtifactsByOIDFromMilestoneHash(artifacts_by_milestone);
                
                var rows_by_project_or_group_name = this._getRowsFromMilestoneHash(artifacts_by_milestone);
                
                Ext.Object.each( artifacts_by_milestone, function(milestone, artifacts) {
                    Ext.Array.each(artifacts, function(artifact){
                        var key = me._getProjectGroupIdentifier(artifact.get('Project'));
                        if ( key ) {
                            rows_by_project_or_group_name[key].addArtifact(artifact,milestone);
                        }
                    });
                });
                table_store.loadRecords(Ext.Object.getValues(rows_by_project_or_group_name));
                this._setCardListeners();
                this.fireEvent('gridReady', this, this.grid);
            },
            failure: function(msg) {
                Ext.Msg.alert('Problem loading artifacts', msg);
            }
        });
    },
    
    _getArtifactsByOIDFromMilestoneHash: function(artifacts_by_milestone){
        var artifacts_by_oid = {};
        Ext.Object.each(artifacts_by_milestone, function(key,artifacts) {
            Ext.Array.each(artifacts, function(artifact){
                artifacts_by_oid[artifact.get('ObjectID')] = artifact;
            });
        });
        return artifacts_by_oid;
    },
    
    _setCardListeners: function() {
        var cards = Ext.query('.ts_card');
        
        Ext.Array.each(cards, function(card){
            var card_element = Ext.get(card);
            card_element.on('click', function(evt,c) {
                this._showDialogForPI(c.id);
            },this);
        },this);
    },
    
    _getProjectGroupIdentifier: function(project) {
        var project_group = this.projectGroups[ project._ref ];
        if ( project_group) {
            return project_group;
        }
        
        if ( project_group == "" ) {
            return project.Name;
        }
        
        if ( Ext.isEmpty( this.projectGroups ) || Ext.Object.isEmpty(this.projectGroups) ) {
            return project.Name;
        }
        
        return false;
    },
    
    _getRowsFromMilestoneHash: function(artifacts_by_milestone) {
        var rows_by_project_or_group_name = {};
        var me = this;
        
        Ext.Object.each( artifacts_by_milestone, function(milestone, artifacts){
            Ext.Array.each(artifacts, function(artifact) {
                var key = me._getProjectGroupIdentifier(artifact.get('Project'));
                                
                if ( key ) {
                    rows_by_project_or_group_name[key] = Ext.create('TSTableRow',{
                        Project: key
                    });
                }
                
            });
        });
        
        return rows_by_project_or_group_name;
    },
    
    _setArtifactColor: function(artifacts) {
        var artifacts_with_color = [];
        Ext.Array.each(artifacts, function(artifact){
            if ( ! Ext.isEmpty(artifact) ) {
                var color = this.stateColors.defaultValue || 'Platinum';
                
                if ( artifact.State ) {
                    color = this.stateColors[artifact.State.Name] || this.stateColors.defaultValue || 'Platinum';
                } else {
                    color = this.stateColors[""] || this.stateColors.defaultValue || 'Platinum';
                }
                
                artifact.__StateColor = color;
                artifacts_with_color.push(artifact);
            }
        },this);
        
        return artifacts_with_color;
    },
    
    _loadArtifactsForMilestone: function(milestone_oid, milestone_date) {
        var deferred = Ext.create('Deft.Deferred');
        
        var config = {
            model: this.cardModel,
            fetch: ['FormattedID', 'Name', 'ObjectID','Project','State','Children'],
            filters: [{property:'Milestones.ObjectID', operator: 'contains', value: milestone_oid}]
        };
        
        TSUtilities.loadWSAPIItems(config).then({
            scope: this,
            success: function(artifacts) {
                
                var artifacts_by_milestone = {};
                artifacts_by_milestone[milestone_date] = artifacts;
                deferred.resolve(artifacts_by_milestone);
            },
            failure: function(msg) {
                deferred.reject(msg);
            }
        });

        return deferred;
    },
    
    _showDialogForPI: function(object_id) {
        var artifact = this.artifacts_by_oid[object_id];
        
        Ext.create('Rally.ui.dialog.Dialog', {
            id       : 'popup',
            width    : Ext.getBody().getWidth() - 40,
            height   : Ext.getBody().getHeight() - 40,
            title    : artifact.get('Name'),
            autoShow : true,
            closable : true,
            layout   : 'fit',
            items    : [{
                xtype                : 'rallygrid',
                id                   : 'popupGrid',
                showPagingToolbar    : false,
                disableSelection     : true,
                showRowActionsColumn : false,
                columnCfgs           : [
                    {dataIndex: 'FormattedID', text:'Feature' },
                    {dataIndex: 'Name', text: 'Name' },
                    {dataIndex: 'State', text: 'State' }
                ],
                storeConfig          : {
                    pageSize: 10000,
                    model: 'PortfolioItem', 
                    filters: [{property:'Parent.ObjectID', value: object_id}]
                }
            }]
        });
        
    }
    

});

Ext.define("TSMilestoneRoadmapApp", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    
    settingsScope: 'project',

    config: {
        defaultSettings: {
            colorStateMapping: {
                'defaultValue': 'Platinum',
                'Discovering': 'cyan'
            },
            projectGroups: {}
        }
    },
    
    items: [
        {xtype:'container', itemId:'selector_box', minHeight: 50},
        {xtype:'container', itemId:'display_box'}
    ],
    // TODO
    integrationHeaders : {
        name : "TSMilestoneRoadmapApp"
    },
                        
    launch: function() {
        var me = this;
        this.setLoading("Loading milestones...");
        
        if ( this.down('tsroadmaptable') ) { this.down('tsroadmaptable').destroy(); }
        
        this._getAppropriatePIType().then({
            scope  : this,
            success: function(types) {
                this.setLoading('Loading items...');
                
                this.PortfolioItemType = types[0];
                this.logger.log('PI Type:', this.PortfolioItemType);
                
                var start_date = Rally.util.DateTime.add(new Date(), 'month', -1);
                var colors = this.getSetting('colorStateMapping');
                var project_groups = this.getSetting('projectGroups');
                
                if ( Ext.isString(colors) ) { colors = Ext.JSON.decode(colors); }
                if ( Ext.isString(project_groups) ) { project_groups = Ext.JSON.decode(project_groups); }
                
                this.logger.log("Colors: ", colors);
                this.logger.log("Project Groups: ", project_groups);
                
                this.roadmap = this.down('#display_box').add({ 
                    xtype: 'tsroadmaptable',
                    startDate: start_date,
                    monthCount: 9,
                    stateColors: colors,
                    projectGroups: project_groups,
                    cardModel: this.PortfolioItemType.get('TypePath'),
                    listeners: {
                        gridReady: function() {
                            me.setLoading(false);
                        }
                    }
                });
                
                
            },
            failure: function(msg) {
                Ext.Msg.alert('Problem loading PI Type Names', msg);
            }
        });
    },
    
    _getCardboardConfig: function() {
        return {
            types: [this.PortfolioItemType.get('TypePath')],
            attribute: 'State',
            columnConfig: {
                xtype: 'tsmilestonecolumn'
            }
        };
    },
    
    _getAppropriatePIType: function() {
        var config = {
            model: 'TypeDefinition', 
            fetch: ["TypePath"],
            filters: [ { property:"Ordinal", operator:"=", value:1} ]
        };
        
        return TSUtilities.loadWSAPIItems(config);
    },
    
    _displayGrid: function(store,field_names){
        this.down('#display_box').add({
            xtype: 'rallygrid',
            store: store,
            columnCfgs: field_names
        });
    },
    
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        
        //Ext.apply(this, settings);
        this.launch();
    },
    
    getSettingsFields: function() {
        var me = this;
        var config = this.getSettings();
        var current_project_groups = (config && config.projectGroups) || {};
        
        return [{
            xtype: 'projectgroupsettings',
            name: 'projectGroups',
            fieldLabel: 'Projects to display (optionally make groups)',
            labelAlign: 'left',
            margin: 0,
            value: current_project_groups,
            readyEvent: 'ready'
        },
        {
            name: 'colorStateMapping',
            readyEvent: 'ready',
            fieldLabel: 'Colors by State',
            width: this.getWidth() -10,
            margin: 0,
            height: 200,
            xtype: 'colorsettingsfield',
            handlesEvents: {
                fieldselected: function(field) {
                    this.refreshWithNewField(field);
                }
            },
            listeners: {
                ready: function() {
                    this.fireEvent('colorsettingsready');
                }
            },
            bubbleEvents: 'colorsettingsready'
        }];
    }
});

            
               Rally.launchApp('TSMilestoneRoadmapApp', {
                   name: 'TS Milestone Roadmap'
               });
        });
    </script>
    
    <style type="text/css">

div.ts_card {
    margin: 2px;
    padding: 2px;
    text-align: center;
    font-size: 9px;
    border: 1px solid black !important;
    box-shadow: 3px 3px grey !important;
}
    </style>

</head>
<body></body>
</html>